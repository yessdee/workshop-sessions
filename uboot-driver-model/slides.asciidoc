= U-Boot Device Model

== Device Model

=== Need For Device Model 

 * To group similar devices and to have consistent driver layer acros
   platform.

 * Same driver to support multiple instances of devices.

 * Sequencing same device instances for individual access.

== Device Classes

=== U-Boot Device Layer

* In U-Boot the commands and the board specific codes access the
  peripheral drivers to access the devices.

* The common platform independent codes, would call the driver
  functions directly and usually they are statically linked during
  compilation.

image::figures/u-boot-cmd-layer.png[width=400,align="center"]

=== U-Boot Device Layer (2)

image::figures/i2c-cmd-layer.png[width=400,align="center"]

=== Common Applications Linking to SoC Specific Code 

* For an example the driver of the i2c command, should get linked to
  the processor specific i2c functions at the compile time.

* it can be achieved through conditional compilation with ifdef 

* or with the support of Makefiles, by compiling the relevant
  architecture files.

* to make generic code to access the hardware specific code, we may
  need to have defined apis.

=== Device Class APIs 

* To standardize the APIs provided by the SoC specific drivers and
  simplify the generic codes, the class model was derived.

* A device class represents the devices, which have similar
  functionalities.

* Each device class tries to abstract the below hardware specific
  layer and tries to provide common interface (API) to the above
  layer.

image::figures/i2c-class-layer.png[width=600, align="center"]

=== Classes in U-Boot

For common interfaces the class drivers are available in U-Boot.

* i2c 
* spi
* adc
* rtc
* gpio
* pinmux
* serial
* timer

* if any SoC to be added they may need to define the apis required by
  the device class.

== Device Model

=== Pre Enumerated Devices

 * The CPU's system bus is a pre-enumerated bus, means the controllers
   are allocated with their base address during their production
   itself.

 * Since the bus is non discoverable bus, we cannot probe the
   addresses of the controller from the processor.

 * The memory map of the SoC would be available in datasheet and this
   memory map has to be known to the drivers.

 * Drivers developed for these busses, had hardcoded the controller's
   addresses.

=== SoC Derivatives 

 * In a SoC evolution, there were numerous SoCs designed with slighter
   variation.
 
 * The same peripherals controllers might be used in different SOCs of
   same family. Ex:PXA25x, PXA27X

 * Since the peripheral controllers are, built as HW libraries and
   reused in several processors and usually called as IPs.

 * There also scenarios where same peripheral controllers IP are
   shared across differerent SOC vendors. Ex: DWC USB 3.0 Controller

  * Where there is change only in the resources like base address, irq
    no and dma channel, but not in the register sequence.

=== Compile Time Device Mapping

  * In the drivers which are common for different CPUs, different
    resource information were handled with `ifdef` ladders.

  * And the drivers were mapped to particular resources at compile
    time.

=== Platform Agnostic Drivers 

  * But this platform specific drivers would be less flexible to
    support multiple SoCs.

  * If the drivers has these platform specific resources embedded into
    it, then it cannot be a platform agnostic driver.

  * To develop a platform agnostic driver, the portions other than
    register manipulation, need to be moved out of the driver.

  * So that driver becomes platform agnostic and can be mapped to
    devices at runtime, rather than at compile time.

=== Device Model 

  * In U-Boot the platform related information are moved out of driver
    and it is represented as `device` and provided with a unique
    string as a name to identify themselves.

  * The `device` would represent the driver informations like `Memory
    Regions` of the controller, `IRQ Nos` designated in the particular
    platform.

  * The core logic which manipulates the registers is represented as
    `driver` and they are added to the special linker section for
    `drivers` using linker list technique.

  * Drivers are mapped to the devices that they support using by
    matching the unique string.

=== U-Boot Devices

  * U-Boot devices represent the driver information.

  * devices are provided with a unique string, to identify themselves.

  * devices are added to the special linker section for `driver_info`
    using linker list.
----
static struct atmel_serial_platdata at91sam9260_serial_plat = {
        .base_addr = ATMEL_BASE_DBGU,
};

U_BOOT_DEVICE(at91sam9260_serial) = {
        .name   = "serial_atmel",
        .platdata = &at91sam9260_serial_plat,
};
----

=== U-Boot Driver

 * The U-Boot driver defines itself with unique name for matching,
   UCLASS type and the callbacks for the UClass.

----
static const struct dm_serial_ops atmel_serial_ops = {
        .putc = atmel_serial_putc,
        .pending = atmel_serial_pending,
        .getc = atmel_serial_getc,
        .setbrg = atmel_serial_setbrg,
};

U_BOOT_DRIVER(serial_atmel) = {
        .name   = "serial_atmel",
        .id     = UCLASS_SERIAL,
        .ops    = &atmel_serial_ops,
};

---- 

=== U-Class Core

  * The driver model core matches the device and the driver using the
    unique string.

  * The role of the U-Class driver is match and instantiate multiple
    devices to the same driver by sequence them uniquely.

  * For example if there exist two I2C controllers in a SOC, each I2C
    controller is treated as separate devices and they are mapped to
    drivers and assigned unique bus number by U-Class core.

=== Device Tree for U-Boot Devices 

  * Instead of representing the U-Boot devices in a code, it can be
    moved out of code to the device tree.

  * In U-Boot startup code the device tree is parsed and the U-Boot
    devices are added to a list.
 
  * Now it is possible that U-Boot has only platform agnostic
    drivers, which can be bound to the device dynamically at runtime.

  * Device tree is a text based data store representation in a tree
    format.

=== Sample Device Tree for UART

----
serial@fffff200 {
  compatible = "atmel,at91sam9260-dbgu" ;
                reg = <0xfffff200 0x200>;

};
----