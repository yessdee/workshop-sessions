= Android Kernel

== Kernel Subsystems

=== Role of Kernel

* Supports Multitasking where simultaneously several application can
  un.

* Challenges of multitasking is allowing all the tasks, to share the
  hardware resources like CPU, RAM etc.
 
* Each hardware has to be shared by different techniques.

* Kernel categorized itself into several subsystems for different
  class of devices.

=== CPU 

* CPUs are time sliced per task / application.

* Each application would be given a time slot and if elpased CPU is
  scheduled to another application.

* Scheduler subsystem of kernel takes care of different scheduler
  algorithm and multi-core handling

=== Memory

* Memory is segmented and each segment is provided to each process.

* So each process can run simultaneously

* Kernel has Memory Allocation and Management Subsystem which helps on
  this.

=== Network

* Network device has to be shared among multiple applications by port
  address and device address.

* Network Subsystem of kernel has TCP/IP like several NW stacks in
  them

* Has MAC layer implementation for WiFi.

* Several drivers for different ethernet cards and wifi.
 
=== Storage

* Storage devices can be segmented as partitions, directories and
  files and can be used by several applications.

* Kernel supports block driver model to access the storage devices.

* Kernel supports several filesystems for different type of storage
  and application.

=== Other Devices

* Kernel has several subsystem like

 - input: for keyboard, mouse, touch
 
 - graphics: display, tft 

 - video4Linux: for video playback and capture  
 
 - Alsa: for audio playback and capture

 - External Connectivity: USB, PCIE

=== Miscellaneous Features

* Compression Algorithms

* Crypto Algorithms


=== Android Specific Changes

Android had topped-up the Linux kernel with few features

* Binder - An Inter-Process-Communication mechanism which stays as
  nervous system Android.

* pmem, ashmem - improved Memory allocators and shared memory
  features.

* Logger - An improved logger to log all the android application
  statuses.

* Wakelocks, OOM handling, ADB driver
 

=== Kernel Version

* Latest version of Linux kernel is 5.4

* But Android adopts only the Long Term Stable (LTS) Kernels which may
  get continued bug and security fixes from the community.

* Versions 4.4, 4.9, 4.14, 4.19 and 5.4 are LTS kernels.

* We can get the kernel version  of target using 

----
$ uname -r
----

=== Kernel Debugging by Logs

* Kernel drivers logs thier driver status like debug, info or error
  into kernel buffers.

* These error logs can be viewed using dmesg command

----
$ dmesg
----

* Dmesg logs are considered to be the first step of debugging in Linux
  kernel.


== Kernel Modules

=== Introduction

  * The Linux kernel consists of
    - large base kernel image
    - many small kernel modules located in `/vendor/lib/modules/`.
+
------
[~]$ find -name "*.ko" /vendor/lib/modules/ | head -n 5
/vendor/lib/modules/kernel/lib/crc-itu-t.ko
/vendor/lib/modules/kernel/lib/crc7.ko
/vendor/lib/modules/kernel/lib/crc16.ko
...
------

=== Plugins vs Kernel Modules

  * Lot similar to plug-ins commonly found in web browsers
  * Modules can be dynamically loaded and unloaded
  * By loading modules features can be added to the kernel
  * By unloading modules modules features can be removed from the kernel

=== Advantages of Kernel Modules

  * Smaller Base Kernel Image for Generic Kernels

    - Linux distributions will have to provide generic kernels that
      support all available hardware

    - Without module support, all the drivers would have to be part of
      the base kernel image

    - With module support, all the drivers are available as modules in
      the filesystem

    - Hardware will be detected at boot time and only the required
      modules will be loaded into the kernel

  * Shorter Development Cycle
    - Edit - Compile - Reboot cycle
    - Edit - Compile - Unload - Load cycle


=== What Can be Implemented as Modules?

  * Device Drivers
  * Filesystems - `ext3`, `fat`, `ntfs`
  * Network Protocols - `ipv6`, `ppp`
  * Cryptographic Algorithms - `aes`, `des`, `blowfish`, `sha1`

== Using Modules

=== Listing Modules

  * The list of currently loaded kernel modules can be obtained using
    the `lsmod` command.
+
------
[~]$ lsmod
Module                  Size  Used by
psmouse                35016  0 
radeon                 99744  2 
...
usbcore               112644  2 uhci_hcd
processor              28840  0 
------

=== Unloading a Module

  * An unwanted module can be removed using the `rmmod` command
+
------
[~]$ lsmod | grep rtc
rtc                    12372  0
[~]$ sudo rmmod rtc
[~]$ lsmod | grep rtc
------
+
  * A module can be removed only when it's usage count is at zero

=== Loading a Module

  * Module can be loaded into the kernel using the `insmod`

  * `insmod` command takes the complete path to the module as argument

------
[~]$ sudo insmod /vendor/lib/modules/kernel/drivers/char/rtc.ko 
[~]$ lsmod | grep rtc
rtc                    12372  0
------

=== Module Information

  * Command `modinfo` provides details about a module
+
------
[~]$ /sbin/modinfo /vendor/lib/modules/kernel/drivers/block/loop.ko 
filename:       /lib/modules/2.6.18/kernel/drivers/block/loop.ko
license:        GPL
alias:          block-major-7-*
vermagic:       2.6.18 SMP mod_unload 686 REGPARM gcc-4.1
depends:        
parm:           max_loop:Maximum number of loop devices (1-256) (int)
------

[role="two-column"]
=== Modules and Dependencies

[role="left"]
image::figures/dependencies.png[]

[role="right"]
  * A module can depend on other modules

  * Module load order: `D E B C A`

  * Figuring out the dependencies and loading them in the right order
    can be complex

  * `modprobe` automates the process, loads the dependencies first and
    then loads the requested module


== Need for Device Tree

=== Boot-up in PC

  * In a PC, when the kernel boots up, the kernel can figure out
    address of basic peripherals
    - Either fixed
    - Can be queried from the BIOS

=== Boot-up in ARM

  * ARM SoCs are designed by variety of vendors
    - Differ in RAM base address
    - Differ in the peripheral controllers
    - Differ in the startup and initialization sequence
    - Information cannot be queried from a BIOS

  * In an ARM SoC, when the kernel boots up,
    - Does know the location of peripherals
    - Drivers required to handle the peripherals

=== Solution 1

  * For each SoC / machine, the kernel had board specific setup and
    initialization code

  * The available devices where hard coded into the kernel of each
    machine

  * Boot code will add them as platform devices, with the following
    information
    - Register Address
    - IRQ Numbers

  * Boot Sequence
    - Machine specific code does initialization
    - Required drivers using the platform device information

=== Problem with Solution 1

  * Did a good job of containing the problem to a certain extent

  * Still a lot of code duplication between SoC variants

  * Kernels had to be compiled for each target, and single kernel
    could not support multiple hardware

  * Lot of common code, that was not generalized into frameworks

=== Solution 2: Pure Data Driven Approach

  * In-memory tree-like data structure called the device tree provides
    information about the system

    - base address of RAM
    - available peripherals, and their base addresses

  * Data driven approach, forced lot of code to be converted to
    frameworks: `irq`, `pinctrl`, `gpio`, `clock`, `led`, etc.

  * And machine specific code were converted to drivers within these
    frameworks

  * Now, at boot-up a common code, queries the device tree to figure
    out details of the machine and invokes the appropriate drivers

== Device Tree History

=== Open Firmware

  * Open Firmware: a standard specifying the interface provided by a
    firmware

  * Developed by Sun, and widely used in Sun, Apple and IBM systems

  * Just like the BIOS, it is stored in a ROM, and is the first
    program to execute on power-up

=== Device Tree

  * Among the other things, Open Firmware specifies a way of providing
    device information through device trees

  * The device tree is constructed by the Open Firmware by probing the
    hardware

  * The program loaded by Open Firmware like a bootloader or an
    operating system can access the device tree, through the Client
    Interface

=== Device Tree in Linux

  * PowerPC and SPARC platforms commonly use Open Firmware

  * The Linux kernel on these platforms generally used Open Firmware
    to obtain the device tree

  * In 2005, it was made mandatory for all PowerPC ports to use the
    device tree

  * For those platforms that did not use Open Firmware for booting, a
    Flattened Device Tree representation has created

=== Device Tree in Linux (Contd)

  * "Flattened": passed to the kernel as blob, rather than being
    queried from the firmware at run-time.

  * Source representation called the Device Tree Source and files had
    the extension `.dts`.

  * Binary representation called the Device Tree Binary and files had
    the extension `.dtb`

=== Device Trees in ARM

  * In 2011, the ARM support for the Linux kernel was overflowing with
    patches and lots of copied and duplicated code with minor
    variations

  * The problem was covered in the LWN article at
    http://lwn.net/Articles/439314/

  * Gradually, all machines are being moved to use the device tree

== Syntax

[role="two-column"]
=== Simple Device Tree

[role="left"]
image::figures/simple-dt.png[align="center"]

[role="right"]
------
include::code/simple.dts[]
------

=== Compiling the DTS

  * Device Tree Source (.dts) can be converted to Device Tree Blob
    (.dtb) using the `dtc`
+
------
dtc -O dtb -o simple.dtb simple.dts
------


=== References

* https://source.android.com/devices/architecture/kernel
* https://elinux.org/Android_Kernel_Features